#include "text_renderer.h"
#include <string.h>
#include <stdio.h>


// Framebuffer definition
uint8_t framebuf[X_BYTES * Y_LINES];

// Simple 5x7 font definition
typedef struct {char c; uint8_t data[5];} font_char_t;
static const font_char_t font5x7[] ={
    {' ', {0x00,0x00,0x00,0x00,0x00}},
    {'0', {0x3E,0x51,0x49,0x45,0x3E}},
    {'1', {0x00,0x42,0x7F,0x40,0x00}},
    {'2', {0x62,0x51,0x49,0x49,0x46}},
    {'3', {0x22,0x41,0x49,0x49,0x36}},
    {'4', {0x18,0x14,0x12,0x7F,0x10}},
    {'5', {0x2F,0x49,0x49,0x49,0x31}},
    {'6', {0x3E,0x49,0x49,0x49,0x30}},
    {'7', {0x01,0x71,0x09,0x05,0x03}},
    {'8', {0x36,0x49,0x49,0x49,0x36}},
    {'9', {0x06,0x49,0x49,0x29,0x1E}},
    {':', {0x00,0x36,0x36,0x00,0x00}},
    {'M', {0x7F,0x02,0x0C,0x02,0x7F}},
    {'o', {0x30,0x48,0x48,0x48,0x30}},
    {'i', {0x00,0x00,0x7A,0x00,0x00}},
    {'s', {0x48,0x54,0x54,0x54,0x24}}, 
    {'t', {0x04,0x3E,0x44,0x40,0x20}},
    {'u', {0x3C,0x40,0x40,0x20,0x7C}},
    {'r', {0x7C,0x08,0x04,0x04,0x08}},
    {'e', {0x38,0x54,0x54,0x54,0x18}},
    {'V', {0x1F,0x20,0x40,0x20,0x1F}},
    {'a', {0x20,0x54,0x54,0x54,0x78}},
    {'l', {0x00,0x41,0x7F,0x40,0x00}},
    {'v', {0x0C,0x30,0x40,0x30,0x0C}},
};
static const uint8_t logo[] = {// SKN MOS, 96x32px
0xff, 0xff, 0xff, 0x07, 0x03, 0x03, 0xff, 0xff, 0x03, 0x03, 0xff, 0xff, 0x03, 0x03, 0xff, 0xff, 
0x03, 0x03, 0x07, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0x9f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x1f, 0x3f, 0x7f, 0xdf, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x1f, 0x3f, 0x7f, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x0f, 0x1f, 0xff, 0xff, 
0xff, 0xff, 0x07, 0x03, 0x02, 0x03, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 
0x32, 0x32, 0x03, 0x07, 0xff, 0xf1, 0x0e, 0x1f, 0x1f, 0x1e, 0x04, 0x01, 0xf6, 0xfe, 0xfe, 0xfe, 
0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfc, 0xfe, 0xfe, 0xfe, 0xfe, 
0xfe, 0xfe, 0xe0, 0x3c, 0x7e, 0x7e, 0x7e, 0x1d, 0x03, 0xc7, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x30, 0x3c, 0x3e, 0x3e, 0x3e, 0x3e, 0x7e, 0x7e, 0xfd, 0xfd, 0xfc, 0xfc, 0xfc, 0xfe, 0xff, 0xff, 
0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xf0, 0xe0, 0xe0, 0xc0, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xff, 0xcf, 0xf8, 0xf8, 0xfc, 0x78, 0x30, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x7f, 0x7e, 0xfc, 0xf8, 
0xf8, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x01, 0x01, 0x03, 0x07, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x83, 0x81, 0x81, 0xff, 0xff, 0x81, 0x81, 0xff, 0xff, 0x81, 0x81, 0xff, 0xff, 
0x81, 0x81, 0x83, 0xff, 0xff, 0xff, 0xf8, 0xf0, 0xe0, 0xe0, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xde, 0xbf, 0xbf, 0x9f, 
0x8e, 0x80, 0xe7, 0xff, 0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xff, 0xf1, 0xdf, 0xdf, 0x9f, 0x9f, 0x8e, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xff, 0xff, 0xff};

static const int FONT_COUNT = sizeof(font5x7) / sizeof(font5x7[0]);

// Initialize renderer: clear framebuff to white
void text_renderer_init(void){
    memset(framebuf, 0xFF, sizeof(framebuf));
}

// Set a single pixel in framebuff to black
static void set_pixel(int x, int y){
    if( x < 0 || x >= EPD_WIDTH  ||  y < 0 || y >= EPD_HEIGHT) return;
    int idx = y * X_BYTES + (x >> 3);
    int bit = 7 - (x & 7);
     framebuf[idx] &= ~(1 << bit);
}


static void draw_char(int x, int y, char c){
    for (int i = 0; i < FONT_COUNT; i++) {
        if (font5x7[i].c == c){
            for (int col = 0; col < 5; col++){
                uint8_t bits = font5x7[i].data[col];
                for (int row = 0; row < 7; row++){
                    if (bits & (1 << row)){
                        set_pixel(x + col, y + row);
                    }
                }
            }
            return;
        }
    }
}

#define LOGO_W        96
#define LOGO_H        32
#define EPD_WIDTH     250
#define EPD_HEIGHT    122

const int PIXEL_OFFSET  = (EPD_WIDTH  - LOGO_W);
const int BYTE_OFFSET   = PIXEL_OFFSET / 8;            
const int BIT_OFFSET    = PIXEL_OFFSET % 8;
const int LOGO_X_BYTES  = (LOGO_W) / 8;
const int Y_OFFSET      = EPD_HEIGHT - LOGO_H;



static void draw_logo(void) {

    for (int row = 0; row < LOGO_H; row++) {

        int base = (Y_OFFSET + row) * X_BYTES + BYTE_OFFSET;
    
        for (int j = 0; j < LOGO_X_BYTES; j++) {
            uint8_t src = logo[row * LOGO_X_BYTES + j];

            if (BIT_OFFSET == 0) {

                framebuf[base + j] = src;
            } else {
                // MSB to [base+j], LSB to [base+j+1]
                framebuf[base + j]     = (uint8_t)(src >> BIT_OFFSET);
                framebuf[base + j + 1] = (uint8_t)(src << (8 - BIT_OFFSET));
            }
        }
    }
}



static void draw_string(int x0, int y0, const char *s){
    int x = x0;
    int y = y0;
    while (*s){
        if (*s == '\n'){
            y += 8; // line height + spacing
            x = x0; // reset column
        } else{
            draw_char(x, y, *s);
            x += 6; // character width + 1 pixel
        }
        s++;
    }
}

// Tests

// int main() {
    
//     text_renderer_init();

//     int x = 0, y = 0;
//     for (int i = 0; i < FONT_COUNT; i++) {
//         /
//         if (y > (EPD_HEIGHT - 7)) break;

//         draw_char(x, y, font5x7[i].c);

//         x += 8;
//         if (x > 120) {
//             x = 0;
//             y += 8;
//         }
//     }
//     draw_logo();

//     for (int yy = 0; yy < Y_LINES; yy++) {
//         for (int xb = 0; xb < X_BYTES; xb++) {
//             size_t idx = yy * X_BYTES + xb;
//             if (idx >= X_BYTES * Y_LINES) {
//                 fprintf(stderr, "Out of bounds index %zu\n", idx);
//                 return 1;
//             }
//             uint8_t byte = framebuf[idx];
//             for (int bit = 7; bit >= 0; bit--) {
//                 putchar((byte & (1 << bit)) ? ' ' : 'x');
//             }
//         }
//         putchar('\n');
//     }

//     return 0;
// }